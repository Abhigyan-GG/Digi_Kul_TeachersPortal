<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Session ‚Ä¢ Digi Kul</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container-fluid">
            <a class="navbar-brand" href="/api/teacher/dashboard">
                <i class="bi bi-mortarboard me-2"></i>
                Digi Kul - Live Session
            </a>
            <div class="navbar-nav ms-auto">
                <div id="networkStatus" class="navbar-text me-3">
                    <i class="bi bi-wifi text-light"></i>
                    <span class="text-light">Checking...</span>
                </div>
                <span class="navbar-text me-3">
                    <i class="bi bi-person-circle me-1"></i>
                    Teacher
                </span>
                <button class="btn btn-outline-light" onclick="leaveSession()">
                    <i class="bi bi-box-arrow-right me-1"></i>Leave Session
                </button>
            </div>
        </div>
    </nav>

<style>
    .main-container {
        display: flex;
        height: calc(100vh - 120px);
        gap: 1rem;
    }
    
    .video-container {
        flex: 2;
        background: #000;
        border-radius: 10px;
        overflow: hidden;
        position: relative;
    }
    
    .video-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 1rem;
        padding: 1rem;
        height: 100%;
        overflow-y: auto;
    }
    
    /* Zoom-style layout when screen sharing is active */
    .video-grid.screen-sharing {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto;
    }
    
    .video-grid.screen-sharing .video-wrapper.screenshare {
        grid-column: 1 / -1;
        grid-row: 1;
        height: 70vh;
    }
    
    .video-grid.screen-sharing .video-wrapper:not(.screenshare) {
        grid-column: auto;
        grid-row: 2;
        height: 100px;
    }
    
    .video-wrapper {
        position: relative;
        background: #333;
        border-radius: 8px;
        overflow: hidden;
        min-height: 200px;
        transition: all 0.3s ease;
    }
    
    .video-wrapper.teacher {
        border: 3px solid #28a745;
    }
    
    .video-wrapper.student {
        border: 2px solid #6c757d;
    }
    
    .video-wrapper.screenshare {
        border: 4px solid #ffc107;
    }
    
    .video-wrapper video {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    
    .screenshare video {
        object-fit: contain;
    }
    
    .video-label {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 12px;
    }
    
    .video-controls {
        position: absolute;
        bottom: 10px;
        right: 10px;
        display: flex;
        gap: 5px;
    }
    
    .control-btn-small {
        width: 30px;
        height: 30px;
        border: none;
        border-radius: 50%;
        background: rgba(0,0,0,0.7);
        color: white;
        font-size: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .sidebar {
        width: 350px;
        background: white;
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .sidebar-tabs {
        display: flex;
        border-bottom: 1px solid #eee;
    }
    
    .sidebar-tab {
        flex: 1;
        padding: 12px;
        border: none;
        background: none;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s;
    }
    
    .sidebar-tab.active {
        background: #007bff;
        color: white;
    }
    
    .tab-panel {
        flex: 1;
        display: none;
        flex-direction: column;
    }
    
    .tab-panel.active {
        display: flex;
    }
    
    .polls-container {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
    }
    
    .poll-card {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    .poll-question {
        font-weight: bold;
        margin-bottom: 1rem;
        color: #333;
    }
    
    .poll-option {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        margin: 5px 0;
        background: white;
        border: 1px solid #ddd;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s;
    }
    
    .poll-option:hover {
        background: #e9ecef;
    }
    
    .poll-option.selected {
        background: #007bff;
        color: white;
    }
    
    .poll-results {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid #ddd;
    }
    
    .poll-result-bar {
        display: flex;
        align-items: center;
        margin: 5px 0;
    }
    
    .poll-result-label {
        width: 100px;
        font-size: 12px;
    }
    
    .poll-result-progress {
        flex: 1;
        height: 20px;
        background: #e9ecef;
        border-radius: 10px;
        margin: 0 10px;
        overflow: hidden;
    }
    
    .poll-result-fill {
        height: 100%;
        background: #007bff;
        transition: width 0.3s;
    }
    
    .poll-result-count {
        width: 50px;
        text-align: right;
        font-size: 12px;
        font-weight: bold;
    }
    
    .participant-item {
        display: flex;
        align-items: center;
        padding: 10px;
        margin: 5px 0;
        background: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #dee2e6;
        min-height: 60px;
    }
    
    .participant-info {
        flex: 1;
        min-width: 0;
    }
    
    .participant-name {
        font-weight: bold;
        color: #333;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .participant-type {
        font-size: 12px;
        color: #666;
        text-transform: capitalize;
    }
    
    .create-poll-form {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    .create-poll-form input,
    .create-poll-form button {
        width: 100%;
        padding: 8px;
        margin: 5px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
    }
    
    .create-poll-form button {
        background: #007bff;
        color: white;
        border: none;
        cursor: pointer;
    }
    
    .poll-option-input {
        display: flex;
        gap: 5px;
        margin: 5px 0;
    }
    
    .poll-option-input input {
        flex: 1;
    }
    
    .poll-option-input button {
        width: auto;
        padding: 8px 12px;
        background: #dc3545;
    }
    
    .session-controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        background: rgba(0,0,0,0.8);
        padding: 10px 20px;
        border-radius: 25px;
        z-index: 1000;
    }
    
    .network-status {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 12px;
        padding: 5px 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        min-width: 120px;
    }
    
    .control-btn {
        width: 50px;
        height: 50px;
        border: none;
        border-radius: 50%;
        background: #6c757d;
        color: white;
        font-size: 20px;
        cursor: pointer;
        transition: all 0.3s;
    }
    
    .control-btn.active {
        background: #28a745;
    }
    
    .control-btn:hover {
        transform: scale(1.1);
    }
    
    .control-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .alert {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 20px;
        border-radius: 5px;
        color: white;
        font-weight: bold;
        z-index: 1001;
        display: none;
    }
    
    .alert-error {
        background: #dc3545;
    }
    
    .alert-success {
        background: #28a745;
    }
    
    @media (max-width: 768px) {
        .main-container {
            flex-direction: column;
            height: auto;
        }
        
        .sidebar {
            width: 100%;
            height: 300px;
        }
        
        .video-grid {
            grid-template-columns: 1fr;
        }
    }
</style>

<div class="main-container">
    <div class="video-container">
        <div class="video-grid" id="video-grid">
            <!-- Video elements will be added here dynamically -->
        </div>
    </div>
    
    <div class="sidebar">
        <div class="sidebar-tabs">
            <button class="sidebar-tab active" onclick="switchSidebarTab('polls')">üìä Polls</button>
            <button class="sidebar-tab" onclick="switchSidebarTab('materials')">üìÅ Materials</button>
            <button class="sidebar-tab" onclick="switchSidebarTab('whiteboard')">üé® Whiteboard</button>
            <button class="sidebar-tab" onclick="switchSidebarTab('chat')">üí¨ Chat</button>
            <button class="sidebar-tab" onclick="switchSidebarTab('participants')">üë• People</button>
        </div>
        
        <!-- Polls Panel -->
        <div id="polls-panel" class="tab-panel active">
            <div class="polls-container" id="polls-container">
                <div class="create-poll-form" id="create-poll-form">
                    <h4>Create New Poll</h4>
                    <input type="text" id="poll-question" placeholder="Enter poll question...">
                    <div id="poll-options">
                        <div class="poll-option-input">
                            <input type="text" placeholder="Option 1" class="poll-option-text">
                            <button onclick="removePollOption(this)">√ó</button>
                        </div>
                        <div class="poll-option-input">
                            <input type="text" placeholder="Option 2" class="poll-option-text">
                            <button onclick="removePollOption(this)">√ó</button>
                        </div>
                    </div>
                    <button onclick="addPollOption()">+ Add Option</button>
                    <button onclick="createPoll()">Create Poll</button>
                </div>
                <div id="polls-list">
                    <!-- Polls will be added here -->
                </div>
            </div>
        </div>
        
        <!-- Materials Panel -->
        <div id="materials-panel" class="tab-panel">
            <div class="polls-container" id="materials-container">
                <h4>Lecture Materials</h4>
                <div id="materials-list">
                    <!-- Materials will be added here -->
                </div>
            </div>
        </div>
        
        <!-- Whiteboard Panel -->
        <div id="whiteboard-panel" class="tab-panel">
            <div class="polls-container" id="whiteboard-container">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h4>Whiteboard</h4>
                    <div style="display: flex; gap: 5px;">
                        <button onclick="clearWhiteboard()" style="padding: 5px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Clear</button>
                    </div>
                </div>
                <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                    <button onclick="setWhiteboardTool('pen')" id="pen-tool" style="padding: 8px 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">‚úèÔ∏è Pen</button>
                    <button onclick="setWhiteboardTool('eraser')" id="eraser-tool" style="padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">üßπ Eraser</button>
                    <input type="color" id="color-picker" onchange="setWhiteboardColor(this.value)" style="width: 40px; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                    <input type="range" id="brush-size" min="1" max="10" value="3" onchange="setBrushSize(this.value)" style="width: 80px;">
                </div>
                <canvas id="whiteboard-canvas" width="300" height="400" style="border: 2px solid #ddd; border-radius: 8px; cursor: crosshair; background: white;"></canvas>
            </div>
        </div>
        
        <!-- Chat Panel -->
        <div id="chat-panel" class="tab-panel">
            <div class="polls-container" id="chat-container">
                <div id="chat-messages" style="height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin-bottom: 10px;">
                    <!-- Chat messages will appear here -->
                </div>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="chat-input" placeholder="Type a message..." style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <button onclick="sendChatMessage()" style="padding: 8px 15px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Send</button>
                </div>
            </div>
        </div>
        
        <!-- Participants Panel -->
        <div id="participants-panel" class="tab-panel">
            <div class="polls-container" id="participants-container">
                <h4>Session Participants</h4>
                <div id="participants-list" style="max-height: 300px; overflow-y: auto;">
                    <!-- Participants will be added here -->
                </div>
                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ddd;">
                    <h5>Session Health</h5>
                    <div id="session-health" style="font-size:13px;">
                        <div id="health-participants">Participants: --</div>
                        <div id="health-recording">Recording: --</div>
                        <div id="health-reports" style="margin-top:8px; max-height:120px; overflow:auto;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Session Controls -->
<div class="session-controls">
    <div id="participants-count">üë• 0 participants</div>
    <div id="networkStatus" class="network-status">
        <i class="bi bi-wifi text-success"></i>
        <span class="text-success">Checking...</span>
    </div>
    <button class="control-btn" id="mic-btn" title="Microphone">üé§</button>
    <button class="control-btn" id="cam-btn" title="Camera">üìπ</button>
    <button class="control-btn" id="screen-btn" title="Share Screen">üñ•Ô∏è</button>
    <button class="control-btn" id="record-btn" title="Start Recording" style="background: #ffc107;">üî¥</button>
    <button class="control-btn" id="leave-btn" title="Leave Session" style="background: #dc3545;">‚ùå</button>
</div>

<div id="alert" class="alert"></div>

<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
<script>
    // Global variables
    let socket = null;
    let currentUser = null;
    let sessionId = null;
    let isMuted = false;
    let isVideoOff = false;
    let isScreenSharing = false;
    let isRecording = false;
    let localStream = null;
    let originalCameraStream = null; // Store original camera stream for restoration
    let peerConnections = new Map();
    let remoteStreams = new Map();
    let mediaRecorder = null;
    let recordedChunks = [];
    let currentLectureId = null;
    let polls = [];
    let userVotes = new Map();
    let connectionQuality = 'high'; // Track connection quality
    let bandwidthMonitor = null; // Monitor bandwidth
    
    // Whiteboard variables
    let whiteboardCanvas = null;
    let whiteboardCtx = null;
    let isDrawing = false;
    let currentTool = 'pen';
    let currentColor = '#000000';
    let brushSize = 3;
    let lastX = 0;
    let lastY = 0;
    
    // WebRTC configuration
    const rtcConfig = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };
    
    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Get session ID from URL
        const pathParts = window.location.pathname.split('/');
        sessionId = pathParts[pathParts.length - 1];
        
        initializeSession();
        setupEventListeners();
    });
    
    async function initializeSession() {
        try {
            // Get user info from Flask session
            const userType = '{{ session.user_type }}';
            const userName = '{{ session.user_name }}';
            const userId = '{{ session.user_id }}';
            
            currentUser = {
                id: userId,
                type: userType,
                name: userName
            };
            
            // Initialize socket directly
            socket = io({
                reconnection: true,
                reconnectionAttempts: 10,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                timeout: 20000
            });
            
            // Setup socket listeners
            setupSocketListeners();
            
            // Get user media (video and audio for teachers)
            await getUserMedia();
            
            // Join the session room
            socket.on('connect', function() {
                console.log('Socket connected, joining session:', sessionId);
                socket.emit('join_session', {
                    session_id: sessionId,
                    role: 'teacher'
                });
                
                // Update UI to show connected status
                updateNetworkStatus('Good');
            });
            
            // Get lecture ID from server template variable
            currentLectureId = '{{ lecture_id }}';
            
            console.log('Current Lecture ID:', currentLectureId);
            
            // Load polls and materials if we have a valid lecture ID
            if (currentLectureId && currentLectureId !== 'None' && currentLectureId !== '' && currentLectureId !== 'undefined') {
                loadPolls();
                loadMaterials();
            } else {
                console.warn('No valid lecture ID found, polls will not be loaded');
            }
            
            // Initialize whiteboard
            initializeWhiteboard();
            
            // Start bandwidth monitoring
            startBandwidthMonitoring();
            // Start periodic quality reporting and health polling
            try { startQualityReporting(); } catch(e){ console.warn('startQualityReporting failed', e); }
            
        } catch (error) {
            console.error('Failed to initialize session:', error);
            showError('Failed to join session: ' + error.message);
        }
    }
    
    // Update network status in the UI
    function updateNetworkStatus(status) {
        const networkElement = document.getElementById('networkStatus');
        if (!networkElement) return;
        
        let icon, text, colorClass;
        
        switch(status) {
            case 'Good':
                icon = 'bi-wifi';
                text = 'Good Connection';
                colorClass = 'text-success';
                break;
            case 'Fair':
                icon = 'bi-wifi-1';
                text = 'Fair Connection';
                colorClass = 'text-warning';
                break;
            case 'Poor':
                icon = 'bi-wifi-2';
                text = 'Poor Connection';
                colorClass = 'text-danger';
                break;
            case 'Offline':
                icon = 'bi-wifi-off';
                text = 'Disconnected';
                colorClass = 'text-danger';
                break;
            default:
                icon = 'bi-wifi';
                text = 'Checking...';
                colorClass = 'text-secondary';
        }
        
        networkElement.innerHTML = `
            <i class="bi ${icon} ${colorClass}"></i>
            <span class="${colorClass}">${text}</span>
        `;
    }
    
    function setupSocketListeners() {
        // Connection events
        socket.on('connect', function() {
            console.log('Socket connected, joining session:', sessionId);
            updateNetworkStatus('Good');
            
            // Join the session as teacher
            socket.emit('join_session', {
                session_id: sessionId,
                role: 'teacher',
                user_id: currentUser.id,
                user_name: currentUser.name
            });
            
            // Add self to participants list immediately for better UX
            addParticipant({
                user_id: currentUser.id,
                user_name: currentUser.name,
                role: 'teacher'
            });
        });
        
        socket.on('disconnect', function() {
            console.log('Socket disconnected');
            updateNetworkStatus('Offline');
        });
        
        socket.on('connect_error', function(error) {
            console.error('Connection error:', error);
            updateNetworkStatus('Poor');
        });
        
        socket.on('session_info', (data) => {
            updateParticipantsList(data.participants);
            // Initiate WebRTC connections with all participants
            data.participants.forEach(participant => {
                if (participant.user_id !== currentUser.id) {
                    initiateCall(participant.user_id);
                }
            });
        });
        
        socket.on('user_joined', (data) => {
            addParticipant(data);
            document.getElementById('participants-count').textContent = `üë• ${data.participants_count} participants`;
            addChatMessage('system', `${data.user_name} joined the session`);
            
            // Initiate WebRTC connection with new user
            if (data.user_id !== currentUser.id) {
                initiateCall(data.user_id);
            }
        });
        
        socket.on('user_left', (data) => {
            removeParticipant(data.user_id);
            document.getElementById('participants-count').textContent = `üë• ${data.participants_count} participants`;
            addChatMessage('system', `${data.user_name} left the session`);
        });
        
        socket.on('session_participants', (participants) => {
            console.log('Received session participants:', participants);
            updateParticipantsList(participants);
            // Also update the participants count
            document.getElementById('participants-count').textContent = `üë• ${participants.length} participants`;
        });
        
        socket.on('webrtc_offer', async (data) => {
            await handleWebRTCOffer(data);
        });
        
        socket.on('webrtc_answer', async (data) => {
            await handleWebRTCAnswer(data);
        });
        
        socket.on('ice_candidate', async (data) => {
            await handleICECandidate(data);
        });
        
        socket.on('chat_message', (data) => {
            console.log('Received chat message:', data);
            addChatMessage(data.user_name, data.message, data.timestamp, data.user_id === currentUser.id);
        });
        
        socket.on('poll_created', (data) => {
            polls.unshift(data.poll);
            renderPolls();
        });
        
        socket.on('poll_vote', (data) => {
            updatePollResults(data.poll_id, data.results);
        });
        
        socket.on('whiteboard_draw', (data) => {
            // Don't process our own drawing events
            if (data.user_id === currentUser.id) return;
            
            // Draw the received drawing data
            drawRemoteWhiteboard(data.drawing_data);
        });
        
        socket.on('whiteboard_clear', (data) => {
            // Don't process our own clear events
            if (data.user_id === currentUser.id) return;
            
            // Clear the whiteboard
            if (whiteboardCtx) {
                whiteboardCtx.clearRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
            }
        });
    }
    
    async function getUserMedia() {
        try {
            // Start with conservative settings for better bandwidth optimization
            localStream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 640, max: 960 },
                    height: { ideal: 480, max: 720 },
                    frameRate: { ideal: 15, max: 30 }
                },
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });
            
            // Create local video element
            createVideoElement(currentUser.id, localStream, true);
            
            // Enable controls
            document.getElementById('mic-btn').classList.add('active');
            document.getElementById('cam-btn').classList.add('active');
            
        } catch (error) {
            console.error('Failed to get user media:', error);
            showError('Failed to access camera/microphone');
        }
    }
    
    function createVideoElement(userId, stream, isLocal = false) {
        console.log('Creating video element for user:', userId, 'isLocal:', isLocal);
        const videoGrid = document.getElementById('video-grid');
        
        // Remove existing video for this user
        const existingVideo = document.getElementById(`video-${userId}`);
        if (existingVideo) {
            existingVideo.parentElement.remove();
        }
        
        const videoWrapper = document.createElement('div');
        videoWrapper.className = `video-wrapper ${isLocal ? 'local' : (currentUser.type === 'teacher' ? 'teacher' : 'student')}`;
        videoWrapper.id = `wrapper-${userId}`;
        
        const video = document.createElement('video');
        video.id = `video-${userId}`;
        video.srcObject = stream;
        video.autoplay = true;
        video.muted = isLocal;
        video.playsInline = true;
        
        const label = document.createElement('div');
        label.className = 'video-label';
        label.textContent = isLocal ? 'You' : `User ${userId.split('_')[1]}`;
        
        const controls = document.createElement('div');
        controls.className = 'video-controls';
        
        const micIcon = document.createElement('button');
        micIcon.className = 'control-btn-small';
        micIcon.innerHTML = 'üé§';
        micIcon.title = 'Mute/Unmute';
        
        const camIcon = document.createElement('button');
        camIcon.className = 'control-btn-small';
        camIcon.innerHTML = 'üìπ';
        camIcon.title = 'Camera On/Off';
        
        controls.appendChild(micIcon);
        controls.appendChild(camIcon);
        
        videoWrapper.appendChild(video);
        videoWrapper.appendChild(label);
        videoWrapper.appendChild(controls);
        
        videoGrid.appendChild(videoWrapper);
    }
    
    async function handleWebRTCOffer(data) {
        try {
            console.log('Handling WebRTC offer from:', data.from_user_id);
            const peerConnection = new RTCPeerConnection(rtcConfig);
            peerConnections.set(data.from_user_id, peerConnection);
            
            // Add local stream
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                console.log('Added local stream to peer connection');
            }
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                console.log('Received remote stream from:', data.from_user_id);
                const remoteStream = event.streams[0];
                remoteStreams.set(data.from_user_id, remoteStream);
                createVideoElement(data.from_user_id, remoteStream);
            };
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice_candidate', {
                        session_id: sessionId,
                        target_user_id: data.from_user_id,
                        candidate: event.candidate,
                        from_user_id: currentUser.id
                    });
                }
            };
            
            // Set remote description
            await peerConnection.setRemoteDescription(data.offer);
            console.log('Set remote description');
            
            // Create answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            console.log('Created and set local answer');
            
            // Send answer
            socket.emit('webrtc_answer', {
                session_id: sessionId,
                target_user_id: data.from_user_id,
                answer: answer,
                from_user_id: currentUser.id
            });
            console.log('Sent WebRTC answer to:', data.from_user_id);
            
        } catch (error) {
            console.error('Failed to handle WebRTC offer:', error);
        }
    }
    
    async function handleWebRTCAnswer(data) {
        try {
            const peerConnection = peerConnections.get(data.from_user_id);
            if (peerConnection) {
                await peerConnection.setRemoteDescription(data.answer);
            }
        } catch (error) {
            console.error('Failed to handle WebRTC answer:', error);
        }
    }
    
    async function handleICECandidate(data) {
        try {
            const peerConnection = peerConnections.get(data.from_user_id);
            if (peerConnection) {
                await peerConnection.addIceCandidate(data.candidate);
            }
        } catch (error) {
            console.error('Failed to handle ICE candidate:', error);
        }
    }
    
    async function createPeerConnection(targetUserId) {
        const peerConnection = new RTCPeerConnection(rtcConfig);
        peerConnections.set(targetUserId, peerConnection);
        
        // Add local stream
        if (localStream) {
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
        }
        
        // Handle remote stream
        peerConnection.ontrack = (event) => {
            console.log('Received remote stream from:', targetUserId);
            const remoteStream = event.streams[0];
            remoteStreams.set(targetUserId, remoteStream);
            createVideoElement(targetUserId, remoteStream);
        };
        
        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('ice_candidate', {
                    session_id: sessionId,
                    target_user_id: targetUserId,
                    candidate: event.candidate,
                    from_user_id: currentUser.id
                });
            }
        };
        
        return peerConnection;
    }
    
    async function initiateCall(targetUserId) {
        try {
            console.log('Initiating call with:', targetUserId);
            const peerConnection = await createPeerConnection(targetUserId);
            
            // Create offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            // Send offer
            socket.emit('webrtc_offer', {
                session_id: sessionId,
                target_user_id: targetUserId,
                offer: offer,
                from_user_id: currentUser.id
            });
            
            console.log('Sent WebRTC offer to:', targetUserId);
        } catch (error) {
            console.error('Failed to initiate call:', error);
        }
    }
    
    function setupEventListeners() {
        // Microphone toggle
        document.getElementById('mic-btn').addEventListener('click', toggleMicrophone);
        
        // Camera toggle
        document.getElementById('cam-btn').addEventListener('click', toggleCamera);
        
        // Screen sharing
        document.getElementById('screen-btn').addEventListener('click', toggleScreenShare);
        
        // Recording
        document.getElementById('record-btn').addEventListener('click', toggleRecording);
        
        // Leave session
        document.getElementById('leave-btn').addEventListener('click', leaveSession);
        
        // Chat input
        document.getElementById('chat-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendChatMessage();
            }
        });
    }
    
    function toggleMicrophone() {
        if (localStream) {
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                isMuted = !audioTrack.enabled;
                
                const btn = document.getElementById('mic-btn');
                if (isMuted) {
                    btn.classList.remove('active');
                    btn.style.background = '#dc3545';
                } else {
                    btn.classList.add('active');
                    btn.style.background = '#28a745';
                }
            }
        }
    }
    
    function toggleCamera() {
        if (localStream) {
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                isVideoOff = !videoTrack.enabled;
                
                const btn = document.getElementById('cam-btn');
                if (isVideoOff) {
                    btn.classList.remove('active');
                    btn.style.background = '#dc3545';
                } else {
                    btn.classList.add('active');
                    btn.style.background = '#28a745';
                }
            }
        }
    }
    
    async function toggleScreenShare() {
        try {
            if (!isScreenSharing) {
                console.log('Starting screen share...');
                
                // Get screen share stream with optimized settings
                const screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        mediaSource: 'screen',
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 },
                        frameRate: { ideal: 15, max: 30 }
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                // Store original camera stream for restoration
                if (localStream && !originalCameraStream) {
                    originalCameraStream = localStream.clone();
                }
                
                // Stop current video track but keep audio
                if (localStream) {
                    localStream.getVideoTracks().forEach(track => track.stop());
                }
                
                // Create new stream with screen share video and original audio
                const newStream = new MediaStream();
                screenStream.getVideoTracks().forEach(track => {
                    track.applyConstraints({
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 15 }
                    });
                    newStream.addTrack(track);
                });
                
                // Keep original audio track if available
                if (originalCameraStream) {
                    originalCameraStream.getAudioTracks().forEach(track => newStream.addTrack(track));
                } else if (localStream) {
                    localStream.getAudioTracks().forEach(track => newStream.addTrack(track));
                }
                
                // Update local stream
                localStream = newStream;
                
                // Update local video element
                const localVideo = document.getElementById('local-video');
                if (localVideo) {
                    localVideo.srcObject = localStream;
                }
                
                // Update all peer connections with new video track
                const videoTrack = screenStream.getVideoTracks()[0];
                peerConnections.forEach((peerConnection, userId) => {
                    const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                    if (sender && videoTrack) {
                        sender.replaceTrack(videoTrack).catch(err => {
                            console.warn('Failed to replace video track:', err);
                        });
                    }
                });
                
                isScreenSharing = true;
                document.getElementById('screen-btn').classList.add('active');
                document.getElementById('screen-btn').innerHTML = '<i class="bi bi-stop-circle"></i>';
                
                // Add screenshare class to video grid and mark screen share video
                const videoGrid = document.getElementById('video-grid');
                videoGrid.classList.add('screen-sharing');
                const localVideoWrapper = document.getElementById(`wrapper-${currentUser.id}`);
                if (localVideoWrapper) {
                    localVideoWrapper.classList.add('screenshare');
                }
                
                // Handle screen share end
                videoTrack.onended = () => {
                    console.log('Screen share ended by user');
                    toggleScreenShare();
                };
                
                console.log('Screen sharing started successfully');
                
                // Notify students about screen sharing
                socket.emit('screen_share_started', {
                    session_id: sessionId,
                    user_id: currentUser.id
                });
                
            } else {
                console.log('Stopping screen share...');
                
                // Stop screen sharing and restore camera
                try {
                    const cameraStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640, max: 1280 },
                            height: { ideal: 480, max: 720 },
                            frameRate: { ideal: 15, max: 30 }
                        },
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    
                    // Stop current screen share tracks
                    if (localStream) {
                        localStream.getVideoTracks().forEach(track => track.stop());
                    }
                    
                    // Create new stream with camera
                    const newStream = new MediaStream();
                    cameraStream.getVideoTracks().forEach(track => {
                        track.applyConstraints({
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            frameRate: { ideal: 15 }
                        });
                        newStream.addTrack(track);
                    });
                    
                    // Keep audio track
                    if (localStream) {
                        localStream.getAudioTracks().forEach(track => newStream.addTrack(track));
                    }
                    
                    // Update local stream
                    localStream = newStream;
                    
                    // Update local video element
                    const localVideo = document.getElementById('local-video');
                    if (localVideo) {
                        localVideo.srcObject = localStream;
                    }
                    
                    // Update all peer connections with camera track
                    const videoTrack = newStream.getVideoTracks()[0];
                    peerConnections.forEach((peerConnection, userId) => {
                        const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                        if (sender && videoTrack) {
                            sender.replaceTrack(videoTrack).catch(err => {
                                console.warn('Failed to replace video track:', err);
                            });
                        }
                    });
                    
                    isScreenSharing = false;
                    document.getElementById('screen-btn').classList.remove('active');
                    document.getElementById('screen-btn').innerHTML = '<i class="bi bi-display"></i>';
                    
                    // Remove screenshare class from video grid
                    const videoGrid = document.getElementById('video-grid');
                    videoGrid.classList.remove('screen-sharing');
                    const localVideoWrapper = document.getElementById(`wrapper-${currentUser.id}`);
                    if (localVideoWrapper) {
                        localVideoWrapper.classList.remove('screenshare');
                    }
                    
                    console.log('Screen sharing stopped, camera restored successfully');
                    
                    // Notify students about screen sharing stop
                    socket.emit('screen_share_stopped', {
                        session_id: sessionId,
                        user_id: currentUser.id
                    });
                    
                } catch (cameraError) {
                    console.error('Failed to restore camera:', cameraError);
                    showAlert('Failed to restore camera. Please refresh the page.', 'error');
                }
            }
        } catch (error) {
            console.error('Failed to toggle screen share:', error);
            showAlert('Screen sharing failed: ' + error.message, 'error');
        }
    }

    function toggleRecording() {
        if (!isRecording) {
            startRecording();
        } else {
            stopRecording();
        }
    }

    function startRecording() {
        try {
            if (!localStream) {
                showAlert('No stream available for recording', 'error');
                return;
            }

            recordedChunks = [];
            mediaRecorder = new MediaRecorder(localStream, {
                mimeType: 'video/webm;codecs=vp9'
            });

            mediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = function() {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                
                // Create download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `lecture_recording_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showAlert('Recording saved successfully!', 'success');
            };

            mediaRecorder.start();
            isRecording = true;
            
            const recordBtn = document.getElementById('record-btn');
            recordBtn.innerHTML = '‚èπÔ∏è';
            recordBtn.title = 'Stop Recording';
            recordBtn.style.background = '#dc3545';
            
            showAlert('Recording started', 'success');
        } catch (error) {
            console.error('Error starting recording:', error);
            showAlert('Failed to start recording: ' + error.message, 'error');
        }
    }

    function stopRecording() {
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            isRecording = false;
            
            const recordBtn = document.getElementById('record-btn');
            recordBtn.innerHTML = 'üî¥';
            recordBtn.title = 'Start Recording';
            recordBtn.style.background = '#ffc107';
            
            showAlert('Recording stopped', 'info');
        }
    }

    function updateParticipantsCount() {
        const count = document.querySelectorAll('.participant').length;
        document.getElementById('participants-count').textContent = `üë• ${count} participants`;
        
        // Update participants list
        const participantsList = document.getElementById('participants-list');
        if (participantsList) {
            participantsList.innerHTML = '';
            document.querySelectorAll('.participant').forEach(participant => {
                const name = participant.querySelector('.participant-name').textContent;
                const isTeacher = participant.classList.contains('teacher');
                const participantDiv = document.createElement('div');
                participantDiv.className = 'participant-item';
                participantDiv.innerHTML = `
                    <div class="participant-info">
                        <span class="participant-name">${name}</span>
                        ${isTeacher ? '<span class="badge bg-primary">Teacher</span>' : '<span class="badge bg-secondary">Student</span>'}
                    </div>
                `;
                participantsList.appendChild(participantDiv);
            });
        }
    }
    
    function leaveSession() {
        if (socket) {
            socket.emit('leave_session', {
                session_id: sessionId,
                user_id: currentUser.id
            });
        }
        
        // Stop local stream
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }
        
        // Close peer connections
        peerConnections.forEach(connection => connection.close());
        
        // Redirect to dashboard
        window.location.href = '/api/teacher/dashboard';
    }
    
    function switchSidebarTab(tabName) {
        // Hide all tab panels
        document.querySelectorAll('.tab-panel').forEach(panel => {
            panel.classList.remove('active');
        });
        
        // Remove active class from all tabs
        document.querySelectorAll('.sidebar-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        
        // Show selected tab panel
        document.getElementById(`${tabName}-panel`).classList.add('active');
        
        // Add active class to clicked tab
        event.target.classList.add('active');
    }
    
    function addParticipant(participant) {
        const participantsList = document.getElementById('participants-list');
        if (!participantsList) {
            console.error('Participants list element not found');
            return;
        }
        
        // Check if participant already exists
        const existingParticipant = document.getElementById(`participant-${participant.user_id}`);
        if (existingParticipant) {
            console.log('Participant already exists:', participant.user_name);
            return;
        }
        
        const participantDiv = document.createElement('div');
        participantDiv.className = `participant ${participant.user_type}`;
        participantDiv.id = `participant-${participant.user_id}`;
        participantDiv.style.cssText = `
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            min-height: 60px;
        `;
        
        const avatar = participant.user_name ? participant.user_name.charAt(0).toUpperCase() : '?';
        const userName = participant.user_name || 'Unknown User';
        const userType = participant.user_type || 'student';
        
        participantDiv.innerHTML = `
            <div style="width: 40px; height: 40px; background: #007bff; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 10px; flex-shrink: 0;">${avatar}</div>
            <div style="flex: 1; min-width: 0;">
                <div style="font-weight: bold; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${userName}</div>
                <div style="font-size: 12px; color: #666; text-transform: capitalize;">${userType}</div>
            </div>
        `;
        
        participantsList.appendChild(participantDiv);
        console.log('Added participant:', userName, 'Type:', userType);
        
        // Update participants count
        updateParticipantsCount();
    }
    
    function removeParticipant(userId) {
        // Remove peer connection
        const peerConnection = peerConnections.get(userId);
        if (peerConnection) {
            peerConnection.close();
            peerConnections.delete(userId);
        }
        
        // Remove video element
        const videoWrapper = document.getElementById(`wrapper-${userId}`);
        if (videoWrapper) {
            videoWrapper.remove();
        }
        
        // Remove participant from list
        const participantDiv = document.getElementById(`participant-${userId}`);
        if (participantDiv) {
            participantDiv.remove();
        }
    }
    
    function updateParticipantsList(participants) {
        const participantsList = document.getElementById('participants-list');
        participantsList.innerHTML = '';
        
        participants.forEach(participant => {
            addParticipant(participant);
        });
    }
    
    function addChatMessage(userName, message, timestamp, isOwn = false) {
        const chatMessages = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.style.marginBottom = '10px';
        messageDiv.style.padding = '8px';
        messageDiv.style.borderRadius = '5px';
        messageDiv.style.backgroundColor = isOwn ? '#007bff' : '#f8f9fa';
        messageDiv.style.color = isOwn ? 'white' : 'black';
        
        const time = timestamp ? new Date(timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
        messageDiv.innerHTML = `<strong>${userName}:</strong> ${message} <small>(${time})</small>`;
        
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    function sendChatMessage() {
        const input = document.getElementById('chat-input');
        const message = input.value.trim();
        
        if (message && socket) {
            console.log('Sending chat message:', message);
            socket.emit('chat_message', {
                session_id: sessionId,
                message: message,
                user_id: currentUser.id,
                user_name: currentUser.name
            });
            
            // Add message to chat immediately for better UX
            addChatMessage(currentUser.name, message, new Date().toISOString(), true);
            input.value = '';
        }
    }
    
    // Poll Functions
    async function loadPolls() {
        if (!currentLectureId) {
            console.warn('No lecture ID available for loading polls');
            return;
        }
        
        console.log('Loading polls for lecture ID:', currentLectureId);
        
        try {
            const res = await fetch(`/api/lectures/${currentLectureId}/polls`, {
                credentials: 'same-origin'
            });
            const data = await res.json();
            
            console.log('Polls API response:', data);
            
            if (data.success) {
                polls = data.polls;
                console.log('Loaded polls:', polls);
                renderPolls();
            } else {
                console.error('Failed to load polls:', data.error);
            }
        } catch (error) {
            console.error('Failed to load polls:', error);
        }
    }
    
    function renderPolls() {
        const container = document.getElementById('polls-list');
        container.innerHTML = '';
        
        if (polls.length === 0) {
            container.innerHTML = '<p style="text-align: center; opacity: 0.7;">No polls available</p>';
            return;
        }
        
        polls.forEach(poll => {
            addPollToUI(poll);
        });
    }
    
    function addPollToUI(poll) {
        const container = document.getElementById('polls-list');
        const pollDiv = document.createElement('div');
        pollDiv.className = 'poll-card';
        pollDiv.id = `poll-${poll.id}`;
        
        const hasVoted = userVotes.has(poll.id);
        const userVote = userVotes.get(poll.id);
        
        let optionsHTML = '';
        poll.options.forEach((option, index) => {
            // Only mark as selected if this is the exact option the user voted for
            const isSelected = hasVoted && userVote === option;
            optionsHTML += `
                <div class="poll-option ${isSelected ? 'selected' : ''}" 
                     onclick="voteOnPoll('${poll.id}', '${option}')">
                    <input type="radio" name="poll-${poll.id}" value="${option}" ${isSelected ? 'checked' : ''} 
                           onclick="event.stopPropagation();" 
                           onchange="voteOnPoll('${poll.id}', '${option}')">
                    <span class="poll-option-text">${option}</span>
                </div>
            `;
        });
        
        pollDiv.innerHTML = `
            <div class="poll-question">${poll.question}</div>
            <div class="poll-options">${optionsHTML}</div>
            <div class="poll-results" id="results-${poll.id}" style="display: ${hasVoted ? 'block' : 'none'};">
                <!-- Results will be populated here -->
            </div>
        `;
        
        container.appendChild(pollDiv);
    }
    
    function voteOnPoll(pollId, option) {
        if (userVotes.has(pollId)) {
            showAlert('You have already voted on this poll', 'error');
            return;
        }
        
        if (socket) {
            socket.emit('poll_vote', {
                session_id: sessionId,
                poll_id: pollId,
                option: option,
                user_id: currentUser.id
            });
            
            userVotes.set(pollId, option);
            showAlert('Vote submitted!', 'success');
            renderPolls(); // Refresh to show selection
        }
    }
    
    function updatePollResults(pollId, results) {
        // This would update the poll results in real-time
        renderPolls();
    }
    
    function addPollOption() {
        const optionsContainer = document.getElementById('poll-options');
        const optionCount = optionsContainer.children.length;
        
        const optionDiv = document.createElement('div');
        optionDiv.className = 'poll-option-input';
        optionDiv.innerHTML = `
            <input type="text" placeholder="Option ${optionCount + 1}" class="poll-option-text">
            <button onclick="removePollOption(this)">√ó</button>
        `;
        
        optionsContainer.appendChild(optionDiv);
    }
    
    function removePollOption(button) {
        if (document.getElementById('poll-options').children.length > 2) {
            button.parentElement.remove();
        }
    }
    
    async function createPoll() {
        const question = document.getElementById('poll-question').value.trim();
        const optionInputs = document.querySelectorAll('.poll-option-text');
        const options = Array.from(optionInputs).map(input => input.value.trim()).filter(option => option);
        
        if (!question) {
            showAlert('Please enter a poll question', 'error');
            return;
        }
        
        if (options.length < 2) {
            showAlert('Please enter at least 2 options', 'error');
            return;
        }
        
        try {
            const res = await fetch(`/api/lectures/${currentLectureId}/polls`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify({
                    question: question,
                    options: options
                })
            });
            
            const data = await res.json();
            
            if (data.success) {
                showAlert('Poll created successfully!', 'success');
                document.getElementById('poll-question').value = '';
                optionInputs.forEach(input => input.value = '');
                loadPolls(); // Refresh polls
            } else {
                showAlert(data.error || 'Failed to create poll', 'error');
            }
        } catch (error) {
            showAlert('Failed to create poll: ' + error.message, 'error');
        }
    }
    
    function showError(message) {
        showAlert(message, 'error');
    }
    
    // Materials Functions
    async function loadMaterials() {
        if (!currentLectureId) {
            console.warn('No lecture ID available for loading materials');
            document.getElementById('materials-list').innerHTML = '<p style="text-align: center; opacity: 0.7;">No lecture selected</p>';
            return;
        }
        
        console.log('Loading materials for lecture ID:', currentLectureId);
        
        try {
            // Show loading indicator
            document.getElementById('materials-list').innerHTML = '<p style="text-align: center; opacity: 0.7;">Loading materials...</p>';
            
            const res = await fetch(`/api/teacher/lecture/${currentLectureId}/materials`, {
                credentials: 'same-origin',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            if (!res.ok) {
                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }
            
            const data = await res.json();
            console.log('Materials API response:', data);
            
            if (data.success && data.materials) {
                if (data.materials.length > 0) {
                    renderMaterials(data.materials);
                } else {
                    document.getElementById('materials-list').innerHTML = '<p style="text-align: center; opacity: 0.7;">No materials available for this lecture</p>';
                }
            } else {
                console.error('Failed to load materials:', data.error);
                document.getElementById('materials-list').innerHTML = '<p style="text-align: center; color: #dc3545;">Failed to load materials: ' + (data.error || 'Unknown error') + '</p>';
            }
        } catch (error) {
            console.error('Failed to load materials:', error);
            document.getElementById('materials-list').innerHTML = '<p style="text-align: center; color: #dc3545;">Failed to load materials: ' + error.message + '</p>';
        }
    }
    
    function renderMaterials(materials) {
        const container = document.getElementById('materials-list');
        
        if (!materials || materials.length === 0) {
            container.innerHTML = '<p style="text-align: center; opacity: 0.7;">No materials available</p>';
            return;
        }
        
        container.innerHTML = materials.map(material => `
            <div class="material-item" style="padding: 10px; border: 1px solid #ddd; border-radius: 5px; margin: 5px 0; background: #f8f9fa;">
                <h5 style="margin: 0 0 5px 0; color: #333;">${material.title}</h5>
                <p style="margin: 0 0 5px 0; font-size: 12px; color: #666;">${material.description || 'No description'}</p>
                <p style="margin: 0 0 10px 0; font-size: 11px; color: #999;">Uploaded: ${new Date(material.uploaded_at).toLocaleString()}</p>
                <div style="display: flex; gap: 5px;">
                    <a href="/api/download/${material.id}" class="btn" style="padding: 5px 10px; background: #007bff; color: white; text-decoration: none; border-radius: 3px; font-size: 12px;">üì• Download</a>
                    <button onclick="deleteMaterial('${material.id}')" class="btn" style="padding: 5px 10px; background: #dc3545; color: white; border: none; border-radius: 3px; font-size: 12px; cursor: pointer;">üóëÔ∏è Delete</button>
                </div>
            </div>
        `).join('');
    }
    
    async function deleteMaterial(materialId) {
        if (!confirm('Are you sure you want to delete this material?')) {
            return;
        }
        
        try {
            const res = await fetch(`/api/teacher/materials/${materialId}`, {
                method: 'DELETE',
                credentials: 'same-origin'
            });
            const data = await res.json();
            
            if (data.success) {
                showAlert('Material deleted successfully!', 'success');
                loadMaterials(); // Refresh materials list
            } else {
                showAlert(data.error || 'Failed to delete material', 'error');
            }
        } catch (error) {
            showAlert('Failed to delete material: ' + error.message, 'error');
        }
    }
    
    function showAlert(message, type) {
        const alert = document.getElementById('alert');
        alert.textContent = message;
        alert.className = `alert alert-${type}`;
        alert.style.display = 'block';
        
        setTimeout(() => {
            alert.style.display = 'none';
        }, 3000);
    }
    
    // Whiteboard Functions
    function attachCanvasResizeHandler(canvas, callback) {
        let resizeTimer;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(function() {
                const rect = canvas.getBoundingClientRect();
                canvas.width = Math.max(300, Math.floor(rect.width));
                canvas.height = Math.max(200, Math.floor(rect.height));
                if (callback) callback();
            }, 200);
        });
    }
    
    function initializeWhiteboard() {
        whiteboardCanvas = document.getElementById('whiteboard-canvas');
        if (whiteboardCanvas) {
            whiteboardCtx = whiteboardCanvas.getContext('2d');
            // Initialize canvas size
            const rect = whiteboardCanvas.getBoundingClientRect();
            whiteboardCanvas.width = Math.max(300, Math.floor(rect.width));
            whiteboardCanvas.height = Math.max(200, Math.floor(rect.height));
            attachCanvasResizeHandler(whiteboardCanvas, function() {
                if (whiteboardCtx) {
                    whiteboardCtx.clearRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
                    try { window.replayStrokeHistory(sessionId || 'default_canvas', whiteboardCtx, whiteboardCanvas); } catch(e){}
                }
            });
            setupWhiteboardEventListeners();
            // Load persisted strokes (if any) and replay
            try {
                const canvasId = sessionId || 'default_canvas';
                window.strokeHistory = window.strokeHistory || {};
                const persisted = window.strokeHistory[canvasId] || (window.loadStrokeHistoryFromStorage ? loadStrokeHistoryFromStorage(canvasId) : []);
                if (persisted && persisted.length) {
                    window.strokeHistory[canvasId] = persisted;
                    try { window.replayStrokeHistory(canvasId, whiteboardCtx, whiteboardCanvas); } catch(e){}
                }
            } catch(e) {
                console.warn('Failed to load persisted whiteboard', e);
            }
            console.log('Whiteboard initialized');
        }
    }
    
    function setupWhiteboardEventListeners() {
        if (!whiteboardCanvas) return;
        
    whiteboardCanvas.addEventListener('mousedown', startDrawing);
    whiteboardCanvas.addEventListener('mousemove', draw);
    whiteboardCanvas.addEventListener('mouseup', stopDrawing);
    whiteboardCanvas.addEventListener('mouseout', stopDrawing);
        
        // Touch events for mobile
        whiteboardCanvas.addEventListener('touchstart', handleTouch);
        whiteboardCanvas.addEventListener('touchmove', handleTouch);
        whiteboardCanvas.addEventListener('touchend', stopDrawing);
    }
    
    function handleTouch(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 'mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        whiteboardCanvas.dispatchEvent(mouseEvent);
    }
    
    function startDrawing(e) {
        isDrawing = true;
        const rect = whiteboardCanvas.getBoundingClientRect();
        lastX = e.clientX - rect.left;
        lastY = e.clientY - rect.top;
    }
    
    function draw(e) {
        if (!isDrawing) return;
        
        const rect = whiteboardCanvas.getBoundingClientRect();
        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;
        
        whiteboardCtx.beginPath();
        whiteboardCtx.moveTo(lastX, lastY);
        whiteboardCtx.lineTo(currentX, currentY);
        whiteboardCtx.strokeStyle = currentTool === 'eraser' ? '#ffffff' : currentColor;
        whiteboardCtx.lineWidth = currentTool === 'eraser' ? brushSize * 3 : brushSize;
        whiteboardCtx.lineCap = 'round';
        whiteboardCtx.lineJoin = 'round';
        whiteboardCtx.stroke();
        
        // Broadcast drawing data using normalized coords + throttle + ACK
        if (socket) {
            const from = normalizePoint(lastX, lastY, whiteboardCanvas);
            const to = normalizePoint(currentX, currentY, whiteboardCanvas);
            const drawingPayload = {
                from: from,
                to: to,
                color: currentTool === 'eraser' ? '#ffffff' : currentColor,
                lineWidth: currentTool === 'eraser' ? brushSize * 3 : brushSize,
                tool: currentTool
            };
            if (!window.__wbThrottledEmit) {
                window.__wbThrottledEmit = throttle(function(payload) {
                    emitWhiteboardDraw(sessionId, payload);
                }, 25);
            }
            window.__wbThrottledEmit(drawingPayload);
        }
        
        lastX = currentX;
        lastY = currentY;
    }
    
    function stopDrawing() {
        isDrawing = false;
    }
    
    function setWhiteboardTool(tool) {
        currentTool = tool;
        
        // Update button styles
        document.getElementById('pen-tool').style.background = tool === 'pen' ? '#0056b3' : '#007bff';
        document.getElementById('eraser-tool').style.background = tool === 'eraser' ? '#545b62' : '#6c757d';
        
        // Update cursor
        whiteboardCanvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
    }
    
    function setWhiteboardColor(color) {
        currentColor = color;
    }
    
    function setBrushSize(size) {
        brushSize = parseInt(size);
    }
    
    function clearWhiteboard() {
        if (whiteboardCtx) {
            whiteboardCtx.clearRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
            
            // Broadcast clear event to other participants
            if (socket) {
                emitWhiteboardClear(sessionId);
            }
            
            showAlert('Whiteboard cleared', 'success');
        }
    }
    
    function drawRemoteWhiteboard(drawingData) {
        if (!whiteboardCtx) return;
        const from = denormalizePoint(drawingData.from.x, drawingData.from.y, whiteboardCanvas);
        const to = denormalizePoint(drawingData.to.x, drawingData.to.y, whiteboardCanvas);

        whiteboardCtx.beginPath();
        whiteboardCtx.moveTo(from.x, from.y);
        whiteboardCtx.lineTo(to.x, to.y);
        whiteboardCtx.strokeStyle = drawingData.color || '#000';
        whiteboardCtx.lineWidth = drawingData.lineWidth || 2;
        whiteboardCtx.lineCap = 'round';
        whiteboardCtx.lineJoin = 'round';
        whiteboardCtx.stroke();
    }
    
    // Enhanced bandwidth monitoring and adaptive quality
    function startBandwidthMonitoring() {
        if (bandwidthMonitor) {
            clearInterval(bandwidthMonitor);
        }
        
        // Initial network status check
        updateNetworkStatus();
        
        bandwidthMonitor = setInterval(async () => {
            try {
                // Test connection speed with multiple methods
                const startTime = performance.now();
                const response = await fetch('/api/teacher/debug/storage', {
                    method: 'HEAD',
                    cache: 'no-cache'
                });
                const endTime = performance.now();
                
                const latency = endTime - startTime;
                const newQuality = determineQuality(latency);
                
                // Update network status display
                updateNetworkStatusDisplay(latency, newQuality);
                
                if (newQuality !== connectionQuality) {
                    connectionQuality = newQuality;
                    adjustStreamQuality();
                    console.log(`Connection quality changed to: ${connectionQuality}`);
                    
                    // Just update the indicator, no notifications
                }
            } catch (error) {
                console.warn('Bandwidth monitoring failed:', error);
                updateNetworkStatusDisplay(null, 'offline');
            }
        }, 5000); // Check every 5 seconds for more responsive monitoring
    }

    // Periodic quality reporting to the server and polling of session health
    let __qualityReportInterval = null;
    let __healthPollInterval = null;

    function startQualityReporting() {
        // send a lightweight quality report every 20s
        if (__qualityReportInterval) clearInterval(__qualityReportInterval);
        sendQualityReport();
        __qualityReportInterval = setInterval(sendQualityReport, 20000);

        // poll session health every 10s to update teacher UI
        if (__healthPollInterval) clearInterval(__healthPollInterval);
        pollSessionHealth();
        __healthPollInterval = setInterval(pollSessionHealth, 10000);
    }

    function stopQualityReporting() {
        if (__qualityReportInterval) clearInterval(__qualityReportInterval);
        if (__healthPollInterval) clearInterval(__healthPollInterval);
    }

    async function sendQualityReport() {
        try {
            if (!socket || !sessionId) return;

            // Compose a basic report using available metrics
            const report = {
                connectionQuality: connectionQuality || 'unknown',
                latencySample: performance.now(),
                participants: (document.getElementById('participants-list') || {children:[]}).children.length,
                timestamp: new Date().toISOString()
            };

            // If we have access to peerConnections, include a rough count
            try {
                report.peer_count = peerConnections ? peerConnections.size : 0;
            } catch (e) { report.peer_count = 0; }

            // Use socket.emit to send the quality_report (server returns an ACK)
            if (window.sendWithAck) {
                sendWithAck('quality_report', { session_id: sessionId, report: report }, function(err, ack){
                    if (err) console.warn('quality_report not acked', err);
                }, 1, 1000);
            } else if (socket && socket.emit) {
                socket.emit('quality_report', { session_id: sessionId, report: report });
            }
        } catch (e) {
            console.warn('sendQualityReport failed', e);
        }
    }

    async function pollSessionHealth() {
        try {
            const res = await fetch(`/api/session_health/${sessionId}`);
            if (!res.ok) return;
            const j = await res.json();
            if (!j.success) return;

            // Update participants and recording status
            const parts = j.participants || [];
            document.getElementById('health-participants').textContent = `Participants: ${parts.length}`;
            document.getElementById('participants-count').textContent = `üë• ${parts.length} participants`;

            const rec = j.recording_status;
            const recTxt = rec ? (rec.status || (rec.recording_stats && rec.recording_stats.duration ? 'recording' : 'idle')) : 'none';
            document.getElementById('health-recording').textContent = `Recording: ${recTxt}`;

            // Render recent quality reports
            const reports = j.quality_reports || [];
            const container = document.getElementById('health-reports');
            container.innerHTML = '';
            reports.slice(-10).reverse().forEach(r => {
                const d = document.createElement('div');
                d.style.fontSize = '12px';
                d.style.marginBottom = '6px';
                d.textContent = `${r.timestamp} ‚Ä¢ user:${r.user_id} ‚Ä¢ q:${r.report.connectionQuality || 'n/a'} peer:${r.report.peer_count || 0}`;
                container.appendChild(d);
            });

        } catch (e) {
            console.warn('pollSessionHealth failed', e);
        }
    }
    
    function updateNetworkStatus() {
        // Check if online
        if (!navigator.onLine) {
            updateNetworkStatusDisplay(null, 'offline');
            return;
        }
        
        // Check connection type if available
        if (navigator.connection) {
            const connection = navigator.connection;
            const effectiveType = connection.effectiveType;
            const downlink = connection.downlink;
            
            console.log(`Network type: ${effectiveType}, Speed: ${downlink}Mbps`);
        }
    }
    
    function updateNetworkStatusDisplay(latency, quality) {
        const statusElement = document.getElementById('networkStatus');
        if (!statusElement) return;
        
        let statusText = '';
        let statusClass = '';
        
        if (quality === 'offline') {
            statusText = 'Offline';
            statusClass = 'text-danger';
        } else if (quality === 'high') {
            statusText = 'Excellent';
            statusClass = 'text-success';
        } else if (quality === 'medium') {
            statusText = 'Good';
            statusClass = 'text-warning';
        } else {
            statusText = 'Poor';
            statusClass = 'text-danger';
        }
        
        statusElement.innerHTML = `
            <i class="bi bi-wifi ${statusClass}"></i>
            <span class="${statusClass}">${statusText}</span>
        `;
    }
    
    function showNetworkNotification(quality) {
        // Network quality is now shown in the status indicator only, no popups
        // Quality indicators are in the top bar and control bar
    }
    
    function determineQuality(latency) {
        if (latency < 100) return 'high';
        if (latency < 300) return 'medium';
        return 'low';
    }
    
    function adjustStreamQuality() {
        if (!localStream) return;
        
        const videoTracks = localStream.getVideoTracks();
        videoTracks.forEach(track => {
            const constraints = getQualityConstraints(connectionQuality);
            track.applyConstraints(constraints).catch(err => {
                console.warn('Failed to apply quality constraints:', err);
            });
        });
        
        // Update peer connections
        peerConnections.forEach((peerConnection, userId) => {
            const senders = peerConnection.getSenders();
            senders.forEach(sender => {
                if (sender.track && sender.track.kind === 'video') {
                    const params = sender.getParameters();
                    if (params.encodings) {
                        params.encodings.forEach(encoding => {
                            encoding.maxBitrate = getMaxBitrate(connectionQuality);
                            encoding.scaleResolutionDownBy = getScaleFactor(connectionQuality);
                        });
                        sender.setParameters(params).catch(err => {
                            console.warn('Failed to set encoding parameters:', err);
                        });
                    }
                }
            });
        });
    }
    
    function getQualityConstraints(quality) {
        switch (quality) {
            case 'high':
                return {
                    width: { ideal: 640, max: 960 },
                    height: { ideal: 480, max: 720 },
                    frameRate: { ideal: 24, max: 30 }
                };
            case 'medium':
                return {
                    width: { ideal: 480, max: 640 },
                    height: { ideal: 360, max: 480 },
                    frameRate: { ideal: 15, max: 20 }
                };
            case 'low':
                return {
                    width: { ideal: 320, max: 480 },
                    height: { ideal: 240, max: 360 },
                    frameRate: { ideal: 10, max: 15 }
                };
            default:
                return {
                    width: { ideal: 480 },
                    height: { ideal: 360 },
                    frameRate: { ideal: 15 }
                };
        }
    }
    
    function getMaxBitrate(quality) {
        switch (quality) {
            case 'high': return 1500000; // 1.5 Mbps (reduced from 2)
            case 'medium': return 750000; // 750 Kbps (reduced from 1 Mbps)
            case 'low': return 300000; // 300 Kbps (reduced from 500)
            default: return 750000;
        }
    }
    
    function getScaleFactor(quality) {
        switch (quality) {
            case 'high': return 1;
            case 'medium': return 1.5;
            case 'low': return 2.5; // More aggressive scaling for low quality
            default: return 1.5;
        }
    }
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (bandwidthMonitor) {
            clearInterval(bandwidthMonitor);
        }
    });
    
</script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
